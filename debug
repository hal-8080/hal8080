--------
Kernel code
	If debug switch is on, jump to debug code
	LUT for Display
--------
User code
--------
MMIO
	Display
	LED's
	Switches
	Buttons
--------
Debug code
--------



--------------------------------

Switches for debug mode
	1: Debug on/off
	2: Step mode / memory mode
		Step mode
			Display: User Program Counter (instructionline in user assembly program)
			Button 1 = execute instruction
		Memory mode
			Registry mode
				Begin op r0
				Display left 2: 0-31 (decimal)
				Display laatste 4: value at register
				Button 1 = previous register
				Button 2 = next register
			Main Memory mode
				Begin op address van program counter
				Address mode
					Show current address, move through addresses
				Value mode
					Show value at selected address 
	3: Registry mode / Main memory mode
	4: Address / Value mode
		Only useful in main memory mode
			Address mode
				Show current address on display 
				Button 1 = previous register
				Button 2 = next register
			Value mode
				See value at current address on display	

------------------------------------------------
HalAssembly Pseudocode

Memory Addresses:
	USERMEM:	00100000 00000000: Start of user memory
	SWMEM:		11100000 00001000: Switches 0-9 and 6 zeroes
	BTNMEM:		11100000 00001010: Buttons 0-3 and 12 zeroes
	
	
SETHI %rd, CONST	SetHigh
	Set upper 8 bits of %rd to CONST
SETLO %rd, CONST	SetLow
	Set lower 8 bits of %rd to CONST

LD %rd, %rs			Load
	%rs contains an address of a word in main memory, the value at that address is loaded into registry %rd
ST %rd, %rs			Store
	%rd contains an address of a word in main memory, the value at %rs is written into that address
LDC(H/L) %rd, CONST		Load Constant
	%rd contains an address of a word in main memory, the CONST is written into (HIGH/LOW) byte at that address

AND %rd, %rs		Bitwise AND 
	Bitwise AND between registries %rd and %rs, store result in %rd
	Set ZEROFLAG to true if result is 0
AND %rd, CONST 		Bitwise AND 
	Bitwise AND between a register and a 5 bit const. First const bit determines if first 12 bits are 0 or 1, last 4 bits are custom


CP %rd, %rs			Copy
	Copy the contents in %rs to %rd


BZERO %rd			Branch if zero
	Jump to address stored in %rd if ZEROFLAG is true
CALL %rd			Call subroutine
	%RetAddr <- PC, PC <- $rd
RET					Return from subroutine 
	PC <- %RetAddr + 2

DISP(L/M/R) CONST, CONST
	L/M/R determines left 2, middle 2 or right 2
	Const are value in lookup table. First Const is displayed on left display, second const on right display
DISP %rs
	Value in %rs is displayed on last 4 segments

------------------------------------------------



# (PNS) = "(Possibly needs seperation)"
#	When loading/storing a value at a dedicated, pre-known memory address I use "LD %reg, MEMADDR". 
#	If the assembler doesn't work out, this needs to be hardcoded and put into a %TempReg with SETHI and SETLO, 
#	and then LD from the address stored in %TempReg into a new registry.


SET DBGREGISTRIES TO 1
SET DBGFLAGS TO 1

	#Store address of start of user program in dbgPC
LD %dbgPC, USERMEM 					(PNS)

	#Store first user program instruction in dbgIR
LD %dbgIR, %dbgPC					(PNS)

LD %ButtonState, BUTTONSTATE		(PNS)
ST PREVBUTTONSTATE, %ButtonState	(PNS)


STARTJUMP
		#Load state of levers in dbgLeverState
	LD %LeverState, LEVERSTATE		(PNS)
	
		#Check if lever 8 is HIGH
		#	if off 	jump to MEMORYMODE
		#	else 	jump to STEPMODE
	SETHI %TempVal, x00
	SETLO %TempVal, x80
	AND %TempVal, %LeverState
	BZERO MEMORYMODE
	BA STEPMODE


STEPMODE
		#Copy the user PC and user IR to dbgAddr en dbgValue so a single display subroutine can be used 
	CP %dbgAddr, %dbgPC
	CP %dbgValue, %dbgIR	
	
		#Check which button went from 0 to 1, store results in %tempVal 
	LD %ButtonState, BUTTONSTATE
	LD %TempVal, PREVBUTTONSTATE
	INV %TempVal
	AND %TempVal, %ButtonState
	ST PREVBUTTONSTATE, %ButtonState
	
	
		#Check if button 3 is HIGH
		#	If LOW, display value
		#	If HIGH, execute instruction
	CP %TempAddr, %TempVal 			#Not an address but its unused atm
	SETHI %TempAddr, x10
	SETLO %TempAddr, x00
	AND %TempVal, %TempAddr
	BZERO ADDRESVALUEDISPLAY
	

	SET DBGREGISTRIES TO 0
	SET DBGFLAGS TO 0	
	#
	#	EXECUTE INSTRUCTION
	#		How to do branch?
	#
	SET DBGREGISTRIES TO 1
	SET DBGFLAGS TO 1
	BA STARTJUMP


MEMORYMODE
		#Check if lever 6 is HIGH
		#	if off 	jump to REGISTRY (UserRegistryReader)
		#	else 	jump to MAINMEM (MainMemoryReader)
	SETHI %TempVal, x02
	SETLO %TempVal, x00
	AND %TempVal, %LeverState
	BZERO REGISTRY
	BA MAINMEM

REGISTRY
		#Change X in "Display register X" to correct value, switch DBGREGISTRES off, execute instruction, switch DBGREGISTRIES on
	
		#Check which button went from 0 to 1, store results in %tempVal 
	LD %ButtonState, BUTTONSTATE
	LD %TempVal, PREVBUTTONSTATE
	INV %TempVal
	AND %TempVal, %ButtonState
	ST PREVBUTTONSTATE, %ButtonState
	
		#Check if button 3 and/or 2 is HIGH
			#If both LOW, jump to REGISTRYSTATIC
			#If either HIGH, jump to REGISTRYMOVE
	CP %TempAddr, %TempVal 			#Not an address but its unused atm
	SETHI %TempAddr, x30
	SETLO %TempAddr, x00
	AND %TempVal, %TempAddr
	BZERO REGISTRYSTATIC
	BA REGISTRYMOVE


REGISTRYMOVE
	LD %tempAddr, LBL 		#Microinstruction for "Display Register XXXX"
	CP %TempVal, TempAddr
	AND %TempVal, 01111
	AND %tempVal, %tempAddr		#%tempVal = 0..0 XXXX
	#
	#	ADD/SUB %tempVal, 1		CHECK IF PREVIOUS/NEXT BUTTON IS HIGH
	#			
	AND %tempVal, 01111
	#
	#	WRITE LAST 4 BITS OF %TempVal TO LEFT 2 DISPLAYS
	#
	AND %tempAddr, 10000		#%tempAddr = X..X 0000
	OR %tempAddr, %tempVal
	ST LBL, %tempAddr
	BA REGISTRYREADOUTPUT


REGISTRYSTATIC
	LD %TempVal, LBL
	AND %TempVal, 01111
	#
	#	WRITE LAST 4 BITS OF %TempVal TO LEFT 2 DISPLAYS
	#
	BA REGISTRYREADOUTPUT

REGISTRYREADOUTPUT
	set DEBGREGISTRIES to 0
LBL:	
	"Display Register XXXX"
	set DEBGREGISTRIES to 1
	
	Jump STARTJUMP



MAINMEM	
	#
	#	CHECK IF BUTTON 3 OR 2 IS HIGH, IF YES JUMP TO MAINMEMSETMOVE
	#
	BA ADDRESVALUEDISPLAY

MAINMEMSETMOVE
	CP %TempVal, %LeverState
	SHIFTR %TempVal, 4
	SETLO %TempVal, x00
	SHIFTL %TempVal, 4		#%TempVal = XXXX 0000 0000 0000
	BZERO MOVE2
	SHIFTL %TempVal, 1
	BZERO MOVE20
	SHIFTL %TempVal, 1
	BZERO MOVE200
	SHIFTL %TempVal, 1
	BZERO MOVE2000
	BA MOVE20000			#If its not 0 after 3 lshifts, lever 3 must be on
	
MAINMEMMOVE2	
	SETHI %TempAddr, x00
	SETLO %TempAddr, x02
	BA MAINMEMCALCMOVE
MAINMEMMOVE20
	SETHI %TempAddr, x00
	SETLO %TempAddr, x14
	BA MAINMEMCALCMOVE
MAINMEMMOVE200
	SETHI %TempAddr, x00
	SETLO %TempAddr, x64
	BA MAINMEMCALCMOVE
MAINMEMMOVE2000
	SETHI %TempAddr, x07
	SETLO %TempAddr, xD0
	BA MAINMEMCALCMOVE
MAINMEMMOVE20000
	SETHI %TempAddr, x4E
	SETLO %TempAddr, x20
	BA MAINMEMCALCMOVE
	

MAINMEMCALCMOVE
	#
	#	IF BUTTON 3 HIGH, SUB %DBGaddr, %TempAddr
	#	IF BUTTON 2 HIGH, ADD %DBGaddr, %TempAddr
	#
	#	ACCOUNT FOR OVERVLOW
	#
	#	LOAD %DBGvalue, %DBGaddr 
	#
	BA ADDRESVALUEDISPLAY

ADDRESVALUEDISPLAY
		#Check if lever 7 is HIGH
		#	if off 	jump to DISPLAYVALUE
		#	else 	jump to DISPLAYADDRES
	SETHI %TempVal, x01
	SETLO %TempVal, x00
	AND %TempVal, %LeverState
	BZERO DISPLAYVALUE
	BA DISPLAYADDRES


DISPLAYVALUE
	DISP %DBGvalue
	BA STARTJUMP


DISPLAYADDRES
	DISP %DBGaddr
	BA STARTJUMP




-Checking if any buttons are high, and then check which buttons are high
	-Corrospondingly add/sub large numbers
-Displaying const from register to display
-Executing instruction (mainly branch)

-Write Assembler


------------------------------------------------

BIOS
	if lever is set, jump to debug
	write 0000 to dbgRegMainMemAddress



DEBUG
	write 1111 to dbgRegMainMemAddress
	Het enige moment dat we user registries willen inlezen is wanneer we ze schrijven naar de displays
	write 0000 to dbgRegMainMemAddress


