--------
Kernel code
	If debug switch is on, jump to debug code
	LUT for Display
--------
User code
--------
MMIO
	Display
	LED's
	Switches
	Buttons
--------
Debug code
--------



--------------------------------

Switches for debug mode
	1: Debug on/off
	2: Step mode / memory mode
		Step mode
			Display: User Program Counter (instructionline in user assembly program)
			Button 1 = execute instruction
		Memory mode
			Registry mode
				Begin op r0
				Display left 2: 0-31 (decimal)
				Display laatste 4: value at register
				Button 1 = previous register
				Button 2 = next register
			Main Memory mode
				Begin op address van program counter
				Address mode
					Show current address, move through addresses
				Value mode
					Show value at selected address 
	3: Registry mode / Main memory mode
	4: Address / Value mode
		Only useful in main memory mode
			Address mode
				Show current address on display 
				Button 1 = previous register
				Button 2 = next register
			Value mode
				See value at current address on display	

------------------------------------------------
HalAssembly Pseudocode

Memory Addresses:
	USERMEM:	00100000 00000000: Start of user memory
	SWMEM:		11100000 00001000: Switches 0-9 and 6 zeroes
	BTNMEM:		11100000 00001010: Buttons 0-3 and 12 zeroes
	
	
SETHI %rd, CONST	SetHigh
	Set upper 8 bits of %rd to CONST
SETLO %rd, CONST	SetLow
	Set lower 8 bits of %rd to CONST

LD %rd, %rs			Load
	%rs contains an address of a word in main memory, the value at that address is loaded into registry %rd
ST %rd, %rs			Store
	%rd contains an address of a word in main memory, the value at %rs is written into that address
LDC %rd, CONST		Load Constant
	%rd contains an address of a word in main memory, the CONST is written into that address

AND %rd, %rs		Bitwise AND 
	Bitwise AND between registries %rd and %rs, store result in %rd
	Set ZEROFLAG to true if result is 0
AND %rd, CONST 		Bitwise AND 
	Bitwise AND between a register and a 5 bit const. First const bit determines if first 12 bits are 0 or 1, last 4 bits are custom


CP %rd, %rs			Copy
	Copy the contents in %rs to %rd


BZERO %rd			Branch if zero
	Jump to address stored in %rd if ZEROFLAG is true
CALL %rd			Call subroutine
	%RetAddr <- PC, PC <- $rd
RET					Return from subroutine 
	PC <- %RetAddr + 2

DISP(L/M/R) CONST, CONST
	L/M/R determines left 2, middle 2 or right 2
	Const are value in lookup table. First Const is displayed on left display, second const on right display
DISP %rs
	Value in %rs is displayed on last 4 segments

------------------------------------------------

	#
	#	FIX THE DEBUG/USER STATUS BIT ISSUE
	#


	#Store address of start of user program in dbgPC (can only do 8 bits at a time)
SETHI %dbgPC, USERMEM
SETLO %dbgPC, USERMEM

	#Store first user program instruction in dbgIR
LD %dbgIR, %dbgPC


STARTJUMP
		#Load state of levers in dbgLeverState (can only do 8 bits at a time)
	SETHI %TempAddr, SWMEM
	SETLO %TempAddr, SWMEM
	LD %LeverState, %TempAddr
	
		#Check if lever 8 is HIGH
		#	if off 	jump to MEMORYMODE
		#	else 	jump to STEPMODE
	SETHI %TempVal, x00
	SETLO %TempVal, x80
	AND %TempVal, %LeverState
	BZERO MEMORYMODE
	BA STEPMODE


STEPMODE
		#Copy the user PC and user IR to dbgAddr en dbgValue so a single display subroutine can be used 
	CP %dbgAddr, %dbgPC
	CP %dbgValue, %dbgIR

	#
	#	IMPORT BUTTONS
	#	
	#	CHECK IF BUTTON3 IS HIGH, IF YES EXECUTE INSTRUCTION
	#

		#Check if lever 7 is HIGH
		#	if off 	write the user PC to display
		#	else	write the user IR to display
	SETHI %TempVal, x01
	SETLO %TempVal, x00
	AND %TempVal, %LeverState
	BZERO DISPADDR
	BA DISPVAL
	

DISPADDR
	#
	#	DISPLAY VALUE IN dbgAddr ONTO DISPLAY
	#	
	BA STARTJUMP
	
DISPVAL
	#
	#	DISPLAY VALUE IN dbgValue ONTO DISPLAY
	#	
	BA STARTJUMP



MEMORYMODE
		#Check if lever 6 is HIGH
		#	if off 	jump to REGISTRY (UserRegistryReader)
		#	else 	jump to MAINMEM (MainMemoryReader)
	SETHI %TempVal, x02
	SETLO %TempVal, x00
	AND %TempVal, %LeverState
	BZERO REGISTRY
	BA MAINMEM

REGISTRY
		#Change X in "Display register X" to correct value, switch DBGREGISTRES off, execute instruction, switch DBGREGISTRIES on
		
	#
	#	CHECK IF BUTTON 3/2 IS HIGH
	#
	Load %tempAddr, LBL 		#Microinstruction for Display Register X
	SetHi %tempVal, 00000000
	SetLo %tempVal, 00001111
	AND %tempVal, %tempAddr		#%tempVal = 0..0 XXXX
	#
	#	ADD/SUB %tempVal, 1		CHECK IF PREVIOUS/NEXT BUTTON IS HIGH
	#			
	AND %tempVal, 01111
	#
	#	WRITE LAST 4 BITS OF %tempVal TO LEFT 2 DISPLAYS
	#
	AND %tempAddr, 10000		#%tempAddr = X..X 0000
	OR %tempAddr, %tempVal
	ST LBL, %tempAddr
	
	set DEBGREGISTRIES to 0
LBL:	
	Display Register XXXX
	set DEBGREGISTRIES to 1
	
	Jump STARTJUMP



MAINMEM	
	#
	#	CHECK IF BUTTON 3 OR 2 IS HIGH, IF YES JUMP TO MAINMEMSETMOVE
	#
	BA ADDRESVALUEDISPLAY

MAINMEMSETMOVE
	CP %TempVal, %LeverState
	SHIFTR %TempVal, 4
	SETLO %TempVal, x00
	SHIFTL %TempVal, 4		#%TempVal = XXXX 0000 0000 0000
	BZERO MOVE2
	SHIFTL %TempVal, 1
	BZERO MOVE20
	SHIFTL %TempVal, 1
	BZERO MOVE200
	SHIFTL %TempVal, 1
	BZERO MOVE2000
	BA MOVE20000			#If its not 0 after 3 lshifts, lever 3 must be on
	
MAINMEMMOVE2	
	SETHI %TempAddr, x00
	SETLO %TempAddr, x02
	BA MAINMEMCALCMOVE
MAINMEMMOVE20
	SETHI %TempAddr, x00
	SETLO %TempAddr, x14
	BA MAINMEMCALCMOVE
MAINMEMMOVE200
	SETHI %TempAddr, x00
	SETLO %TempAddr, x64
	BA MAINMEMCALCMOVE
MAINMEMMOVE2000
	SETHI %TempAddr, x07
	SETLO %TempAddr, xD0
	BA MAINMEMCALCMOVE
MAINMEMMOVE20000
	SETHI %TempAddr, x4E
	SETLO %TempAddr, x20
	BA MAINMEMCALCMOVE
	

MAINMEMCALCMOVE
	#
	#	IF BUTTON 3 HIGH, SUB %DBGaddr, %TempAddr
	#	IF BUTTON 2 HIGH, ADD %DBGaddr, %TempAddr
	#
	#	ACCOUNT FOR OVERVLOW
	#
	#	LOAD %DBGvalue, %DBGaddr 
	#
	BA ADDRESVALUEDISPLAY



ADDRESVALUEDISPLAY
		#Check if lever 7 is HIGH
			#	if off 	jump to DISPLAYVALUE
			#	else 	jump to DISPLAYADDRES
	SETHI %TempVal, x01
	SETLO %TempVal, x00
	AND %TempVal, %LeverState
	BZERO DISPLAYVALUE
	BA DISPLAYADDRES


DISPLAYVALUE
	DISP %DBGvalue
	BA STARTJUMP


DISPLAYADDRES
	DISP %DBGaddr
	BA STARTJUMP







------------------------------------------------

BIOS
	if lever is set, jump to debug
	write 0000 to dbgRegMainMemAddress



DEBUG
	write 1111 to dbgRegMainMemAddress
	Het enige moment dat we user registries willen inlezen is wanneer we ze schrijven naar de displays
	write 0000 to dbgRegMainMemAddress



Buttons low->high




1
2
3
4
5

6: 1
7
8
9
10



DBGREGISTRIES

DBGFLAGS

Display register 0


		Load %tempAddr, LBL 		#Microinstruction for Display Register X
		SetHi %tempVal, 00000000
		SetLo %tempVal, 00001111
		AND %tempVal, %tempAddr		#%tempVal = 0..0 XXXX
		#
		#	ADD/SUB %tempVal, 1		CHECK IF PREVIOUS/NEXT BUTTON IS HIGH
		#			
		AND %tempVal, 01111
		#
		#	WRITE LAST 4 BITS OF %tempVal TO LEFT 2 DISPLAYS
		#
		AND %tempAddr, 10000		#%tempAddr = X..X 0000
		OR %tempAddr, %tempVal
		ST LBL, %tempAddr
		
		set DEBGREGISTRIES to 0
LBL:	Display Register XXXX
		set DEBGREGISTRIES to 1

 
