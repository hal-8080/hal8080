# Debug program
# $r0 = %r0 
# $r1 = %r1

# $RET = Call Return Address
# $dA = ASSEMBLERBRANCH
# $dB = TempVal2
# $dC = TempVal1 
# $dD = ButtonState 
# $dE = LeverState 
# $dF = TempAddr
# $dAD = dbgAddr
# $dVAL = dbgValue 
# $dPC = dbgPC 
# $dIR = dbgIR 
# $PC = Program Counter
# $IR = Instruction Register
#
@DBGREGISTRIES@ = x"AAAA"
@DBGFLAGS@ = x"AAAA"
@USERMEM@ = x"AAAA"
@LEVERSTATE@ = x"AAAA"
@BUTTONSTATE@ = x"AAAA"
@PREVBUTTONSTATE@ = x"AAAA"



ST $r1, @DBGREGISTRIES@
ST $r1, @DBGFLAGS@
	# Store address of start of user program in dbgPC
LD $dPC, @USERMEM@ 					
	# Store first user program instruction in dbgIR
LD $dIR, $dPC				
LD $dD, @BUTTONSTATE@
ST $dD, @PREVBUTTONSTATE@

STARTJUMP:
	ST $r1, @DBGREGISTRIES@
	ST $r1, @DBGFLAGS@

	LD $dE, @LEVERSTATE@	
	
		# Check if lever 8 is HIGH
		# 	if off 	jump to MEMORYMODE
		# 	else 	jump to STEPMODE
	SETHI $dC, x"00"
	SETLO $dC, x"80"
	AND $dC, $dE
	BZERO @MEMORYMODE
	BA @STEPMODE



STEPMODE:
		# Copy the user PC and user IR to dbgAddr en dbgValue so a single display subroutine can be used 
	CP $dAD, $dPC
	CP $dVal, $dIR	
	
		# Check which button went from 0 to 1, store results in $dC
	LD $dD, @BUTTONSTATE@
	LD $dC, @PREVBUTTONSTATE@
	INV $dC, $dC
	AND $dC, $dD
	ST $dD, @PREVBUTTONSTATE@
	
		# Check if button 3 is HIGH
		# 	If LOW, display value
		# 	If HIGH, execute instruction
	SETHI $dB, x"10"
	SETLO $dB, x"00"
	AND $dC, $dB
	BZERO @ADDRESVALUEDISPLAY

			# # # # # EXECUTE USER INSTRUCTION # # # # # 
	LD $dIR, $dPC		# Should not be needed, but doesn't hurt to put here anyways
	CP $dC, $dIR
	SETHI $dB, x"C0"
	SETLO $dB, x"00"	# $dB = 1100 0000 00000 0000
	
	SHIFTR $dC, 6
	SETLO $dC, x"00"
	SHIFTL $dC, 6
	
	SUB $dC, $dB 	# Check if its a branch instruction
	BZERO @PANICITSABRANCHINSTRUCTION
	BA @NOTBRANCHINSTR
	
PANICITSABRANCHINSTRUCTION:
	CP $dC, $dIR
	SHIFTL $dC, 3
	SETLO $dC, x"00"
	SHIFTL $dC, 4 	# COND 0000 0000 0000
	
	SETLO $dB, x"00"
	SETHI $dB, x"40"
	SUB $dB, $dC
	BZERO @USERCALLINSTRUCTION 	# Check if the instruction is a call instruction = 0100
	
	SETLO $dB, x"00"
	SETHI $dB, x"50"
	SUB $dB, $dC
	BZERO @USERRETURNINSTRUCTION 	# Check if the instruction is a return instruction = 0101
	
	SETLO $dB, x"00"
	SETHI $dB, x"00"
	SUB $dB, $dC
	BZERO @BNEGCHECK 	# Check if the instruction is a BNEG instruction = 0000
	
	SETLO $dB, x"00"
	SETHI $dB, x"10"
	SUB $dB, $dC
	BZERO @BZEROCHECK 	# Check if the instruction is a BZERO instruction = 0001
	
	BA @HOP	# If its a branch instruction and not call, return, bneg, bzero, it must be a branch always
	
USERCALLINSTRUCTION:
	CP $RET, $dPC
	BA @HOP

USERRETURNINSTRUCTION:
	CP $dPC, $RET
	LD $dIR, $dPC
	BA @STARTJUMP
	
BNEGCHECK:
	ST $r0, @DBGFLAGS@
	BNEG @HOP
	BA @NOHOP
	
BZEROCHECK:
	ST $r0, @DBGFLAGS@
	BZERO @HOP
	BA @NOHOP

HOP:
	ST $r1, @DBGFLAGS@
	# 
	# Get jump address and put in PC 	DEPENDS ON HOW FLAGS WORK
	# 
	LD $dIR, $dPC
	BA @STARTJUMP
	
NOHOP:
	ST $r1, @DBGFLAGS@
	ADD $dPC, "00010"
	LD $dIR, $dPC
	BA @STARTJUMP
	
NOTBRANCHINSTR:
	ST $r0, @DBGFLAGS@
	ST $dIR, @instr
	ST $r0, @DBGREGISTRIES@
instr:
	AND $r0, $r0 	# DUMMY INSTRUCTION
	ST $r1, @DBGFLAGS@
	ST $r1, @DBGREGISTRIES@
	ADD $dPC, "00010"
	LD $dIR, $dPC
	BA @STARTJUMP



MEMORYMODE:
		# Check if lever 6 is HIGH
		# 	if off 	jump to REGISTRY (UserRegistryReader)
		# 	else 	jump to MAINMEM (MainMemoryReader)
	SETHI $dC, x"02"
	SETLO $dC, x"00"
	AND $dC, $dE
	BZERO @REGISTRY
	BA @MAINMEM



REGISTRY:
		# Change X in "Display register X" to correct value, switch DBGREGISTRIES off, execute instruction, switch DBGREGISTRIES on
	
		# Check which button went from 0 to 1, store results in $dC
	LD $dD, @BUTTONSTATE@
	LD $dC, @PREVBUTTONSTATE@
	INV $dC, $dC
	AND $dC, $dD
	ST $dD, @PREVBUTTONSTATE@
	
		# Check if button 3 and/or 2 is HIGH
			# If both LOW, jump to REGISTRYSTATIC
			# If either HIGH, jump to REGISTRYMOVE
	SETHI $dB, x"30"
	SETLO $dB, x"00"
	AND $dC, $dB
	BZERO @REGISTRYSTATIC
	BA @REGISTRYMOVE

REGISTRYMOVE:
		# If button 3 or 2 is pressed, increment/decrement the XXXX in "Display Register XXXX" 

	LD $dF, @LBL	
	CP $dB, $dF
	AND $dB, "01111"		# $dB = 0..0 XXXX
	
	# In use: DA: LBL("Display registry XXXX")
	# 		TempVal1: Changed buttons
	# 		TempVal2: 0..0 XXXX
	
	CP $dF, $dB
	SHIFTL $dC, 3
	BZERO @REGISTRYMOVEADD
	BA @REGISTRYMOVESUB
	
REGISTRYMOVESUB:
	SUB $dF, x"0001"
	BA @REGISTRYMOVESET

REGISTRYMOVEADD:
	ADD $dF, x"0001"
	BA @REGISTRYMOVESET

REGISTRYMOVESET:
	AND $dF, "01111"
	CP $dC, $dF 	
	LD $dF, @LBL
	AND $dF, "10000"
	OR $dF, $dC
	ST $dF, @LBL
	
	SHIFTL $dC, 4
	OR $dC, "00001"
	SHIFTL $dC, 4
	OR $dC, "01111"	# $dC = 0000XXXX 00011111 = Register number on 1st, EMPTY on 2nd 
	DISPRCL $dC 		# DISP Register number + empty on left 2 displays

	BA @REGISTRYREADOUTPUT

REGISTRYSTATIC:
	LD $dC, @LBL
	AND $dC, "01111"
	
	SHIFTL $dC, 4
	OR $dC, "00001"
	SHIFTL $dC, 4
	OR $dC, "01111"	# $dC = 0000XXXX 00011111 = Register number on 1st, EMPTY on 2nd 
	DISPRCL $dC 		# DISP Register number + empty on left 2 displays
	
	BA @REGISTRYREADOUTPUT

REGISTRYREADOUTPUT:
	ST $r0, @DBGREGISTRIES@ 
LBL:	
	DISPRHR x"0000"		# x"0000" is DUMMY VARIABLE
	ST $r1, @DBGREGISTRIES@ 
	BA @STARTJUMP



MAINMEM:
		# Check which button went from 0 to 1, store results in $dC
	LD $dD, @BUTTONSTATE@
	LD $dC, @PREVBUTTONSTATE@
	INV $dC, $dC
	AND $dC, $dD
	ST $dD, @PREVBUTTONSTATE@
	
		# Check if button 3 and/or 2 is HIGH
		# 	If both LOW, jump to REGISTRYSTATIC
		# 	If either HIGH, jump to REGISTRYMOVE
	SETHI $dB, x"30"
	SETLO $dB, x"00"
	AND $dC, $dB
	BZERO @ADDRESVALUEDISPLAY
	BA @REGISTRYMOVE

MAINMEMSETMOVE:
	CP $dB, $dE
	SHIFTR $dB, 4
	SETLO $dB, x"00"
	SHIFTL $dB, 4		# $dC = XXXX 0000 0000 0000
	BZERO @MAINMEMMOVE2
	SHIFTL $dB, 1
	BZERO @MAINMEMMOVE20
	SHIFTL $dB, 1
	BZERO @MAINMEMMOVE200
	SHIFTL $dB, 1
	BZERO @MAINMEMMOVE2000
	BA @MAINMEMMOVE20000			# If its not 0 after 3 lshifts, lever 3 must be on
	
MAINMEMMOVE2:
	SETHI $dB, x"00"
	SETLO $dB, x"02"
	BA @MAINMEMCALCMOVE
MAINMEMMOVE20:
	SETHI $dB, x"00"
	SETLO $dB, x"14"
	BA @MAINMEMCALCMOVE
MAINMEMMOVE200:
	SETHI $dB, x"00"
	SETLO $dB, x"64"
	BA @MAINMEMCALCMOVE
MAINMEMMOVE2000:
	SETHI $dB, x"07"
	SETLO $dB, x"D0"
	BA @MAINMEMCALCMOVE
MAINMEMMOVE20000:
	SETHI $dB, x"4E"
	SETLO $dB, x"20"
	BA @MAINMEMCALCMOVE

MAINMEMCALCMOVE:
		# $dC holds changed buttons from 0 to 1	
	SHIFTL $dC, 3
	BZERO @MAINMEMMOVEADD
	BA @MAINMEMMOVESUB
	
MAINMEMMOVESUB:
	SUB $dAD, $dB		
	# 
	# 	ACCOUNT FOR OVERFLOW
	# 	NEED EXACT TOP/BOTTOM OF USER MEMORY TO CREATE OVERFLOW COUNTERMEASURES
	# 
	BA @MAINMEMUPDATE

MAINMEMMOVEADD:
	ADD $dAD, $dB
	# 
	# 	ACCOUNT FOR OVERFLOW
	# 	NEED EXACT TOP/BOTTOM OF USER MEMORY TO CREATE OVERFLOW COUNTERMEASURES
	# 
	BA @MAINMEMUPDATE

MAINMEMUPDATE:
	LD $dVal, $dAD 
	BA @ADDRESVALUEDISPLAY
	


ADDRESVALUEDISPLAY:
		# Check if lever 7 is HIGH
		# 	if off 	jump to DISPLAYVALUE
		# 	else 	jump to DISPLAYADDRES
	SETHI $dC, x"01"
	SETLO $dC, x"00"
	AND $dC, $dE
	BZERO @DISPLAYVALUE
	BA @DISPLAYADDRES

DISPLAYVALUE:
	DISPRHR $dVal
	BA @STARTJUMP

DISPLAYADDRES:
	DISPRHR $dAD
	BA @STARTJUMP
